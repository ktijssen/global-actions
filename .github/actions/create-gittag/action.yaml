name: create-gittag
description: Get the git tag used with this commit
author: Kevin Tijssen (TNO)

inputs:
  major:
    description: "The major version number. This parameter is required and represents the major version of the software being built."
    required: true
  minor:
    description: "The minor version number. This parameter represents the minor version of the software being built. The default value is '0' if not specified."
    required: true
  overwriteMajor:
    description: "A boolean flag indicating whether to overwrite the major version to create a lower major version. The default value is 'false'."
    required: true
outputs:
  gitTag:
    description: "The generated Git tag. This output value will be derived from the 'gitTag' output of the 'tag' step in the workflow."
    value: ${{ steps.tag.outputs.gitTag }}

runs:
  using: "composite"
  steps:
    - name: Get gittag
      id: tag
      shell: bash --noprofile --norc -o pipefail {0}
      env: 
        MAJOR: ${{ inputs.major }}
        MINOR: ${{ inputs.minor }}
        OVERWRITE_MAJOR: ${{ inputs.overwriteMajor }}
      run: |

        # Get gittag
        while true; do
          ### Get or Create version number ###
          
          # Get the latest tag of the repo
          ALL_TAGS=$(git fetch --all --tags &> /dev/null)

          if [ "${OVERWRITE_MAJOR}" == "true" ]; then
            CURRENT_TAG=$(git tag --sort v:refname | grep -F v${MAJOR}.  | tail -1)
          else
            CURRENT_TAG=$(git tag --sort v:refname  | tail -1)
          fi

          # Check if there is a current tag
          if [ -z "${CURRENT_TAG}" ]; then
            CURRENT_TAG="v0.0.0"
            SHA_CURRENT_TAG="NoSHA"
          else
            SHA_CURRENT_TAG=$(git rev-parse ${CURRENT_TAG})
          fi

          # Remove prefix "v" from tag if exists
          CURRENT_TAG_WITHOUT_V=$(echo ${CURRENT_TAG} | sed s'/v//')

          # Split up tag in seperated bits
          TAG_BITS=(${CURRENT_TAG_WITHOUT_V//./ })
          TAG_BIT1=${TAG_BITS[0]}
          TAG_BIT2=${TAG_BITS[1]}
          TAG_BIT3=${TAG_BITS[2]}

          # Check if 'major', 'minor' or 'patch' needs to increment
          if [ "${MAJOR}" -gt "${TAG_BIT1}" ]; then
            TAG_BIT1=${MAJOR}
            TAG_BIT2=0
            TAG_BIT3=0
            NEW_GIT_TAG="v${TAG_BIT1}.${TAG_BIT2}.${TAG_BIT3}"
          elif [ "${MAJOR}" -lt "${TAG_BIT1}" ]; then 
            echo "::error::Variable 'major' is lower than current highest major. If you want to use a lower major version, set 'overwriteMajor' to true."
            exit 1    
          elif [ "${MINOR}" -gt "${TAG_BIT2}" ]; then
            TAG_BIT2=${MINOR}
            TAG_BIT3=0
            NEW_GIT_TAG="v${TAG_BIT1}.${TAG_BIT2}.${TAG_BIT3}"
          else
            TAG_BIT3=$((TAG_BIT3+1))
            NEW_GIT_TAG="v${TAG_BIT1}.${TAG_BIT2}.${TAG_BIT3}"
          fi

          # Get the current SHA commit
          SHA_CURRENT_GIT_COMMIT=$(git rev-parse HEAD)

          # Check if the branch is 'main' or 'master'
          if [ ${GITHUB_REF_NAME} == "main" ] || [ ${GITHUB_REF_NAME} == "master" ]; then

            # Look for tag with the same sha
            TAG_EXISTS_SHA=$(git show-ref --tags | grep ${SHA_CURRENT_GIT_COMMIT} | cut -d '/' -f3 | tail -1)

            # Check if the latest commit is already tagged
            if [ ${TAG_EXISTS_SHA} ]; then
              echo "Already a tag on this commit"
              # Export the current tag to GitHub Outputs for later usages
              mkdir -p ~/artifacts/${GITHUB_REPOSITORY}/${GITHUB_RUN_ID}/
              echo "gitTag=${TAG_EXISTS_SHA}" >> $GITHUB_OUTPUT
              echo "gitTag=${TAG_EXISTS_SHA}"
              break
            else
              git tag $NEW_GIT_TAG  --force
              PUSH_TAG=$(git push origin --tags --quiet --force &> /dev/null)

              # Export the tag to GitHub Outputs for later usages
              if [[ $? -eq 0 ]]; then
                mkdir -p ~/artifacts/${GITHUB_REPOSITORY}/${GITHUB_RUN_ID}/
                echo "gitTag=${NEW_GIT_TAG}" >> $GITHUB_OUTPUT
                echo "gitTag=${NEW_GIT_TAG}"
                break
              fi
            fi
          else
            # Get the latest SHA commit
            GITHUB_SHA_SHORT=$(git rev-parse --short HEAD)

            # Export the PR-tag to GitHub Outputs for later usages
            mkdir -p ~/artifacts/${GITHUB_REPOSITORY}/${GITHUB_RUN_ID}/
            echo "gitTag=${NEW_GIT_TAG}-pr-${GITHUB_SHA_SHORT}" >> $GITHUB_OUTPUT
            echo "${NEW_GIT_TAG}-pr-${GITHUB_SHA_SHORT}"
            break
          fi
        done
